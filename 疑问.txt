这是我当前生成物品的代码，我们现在需要来
# item_generator.py

# 包含 ModItem 类和物品生成逻辑 (使用周长优化算法重构形状生成)

import random

import pygame

import sys

import math

import numpy as np # 引入 numpy



try:

    import config as cfg

except ImportError:

    print("错误：item_generator.py 无法导入 config.py。")

    sys.exit()



# --- 全局常量和辅助函数 (用于形状生成和优化) ---



# 从 config 中获取 MOD_PANEL_ROWS 的值

MOD_PANEL_ROWS = cfg.MOD_PANEL_ROWS if hasattr(cfg, 'MOD_PANEL_ROWS') else 6

# 用于形状生成的内部大网格尺寸 (确保有足够的空间移动)

GRID_SIZE = MOD_PANEL_ROWS + 10 # 增加一些裕度，例如默认 16 或 20



def get_bounding_box_dims(cells_set):

    """

    计算单元格集合的边界框尺寸 (行数, 列数)。

    """

    if not cells_set:

        return 0, 0

    

    # 确保处理 Python set of tuples

    if isinstance(cells_set, np.ndarray):

        cells_set = set(map(tuple, cells_set))

        

    rows = [r for r, c in cells_set]

    cols = [c for r, c in cells_set]

    

    if not rows or not cols:

         return 0, 0

         

    # 尺寸 = 最大坐标 - 最小坐标 + 1

    height = max(rows) - min(rows) + 1

    width = max(cols) - min(cols) + 1

    return height, width



def check_dims_constraint(cells_set, max_dim=MOD_PANEL_ROWS):

    """检查尺寸约束：行数或列数至少有一个不超过 max_dim。"""

    height, width = get_bounding_box_dims(cells_set)

    # 必须至少有一维符合限制

    return height <= max_dim or width <= max_dim



def get_min_perimeter(N):

    """计算 N 个单元格形成的最紧凑形状的理论最小周长。"""

    if N <= 0:

        return 0

    if N == 1:

        return 4

    # 接近正方形的周长

    k = math.sqrt(N)

    p_min = 2 * (math.ceil(k) + math.floor(k))

    return int(p_min)



def calculate_perimeter_for_set(cells_set):

    """根据单元格集合计算周长。"""

    perimeter = 0

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] 

    

    # 将输入转换为 Python set 以便快速查找

    if isinstance(cells_set, np.ndarray):

        cells_set = set(map(tuple, cells_set))

    

    for r, c in cells_set:

        for dr, dc in directions:

            nr, nc = r + dr, c + dc

            # 如果邻居在网格外 (边界) 或不在 cells_set 中 (周长边)

            if not (0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE) or (nr, nc) not in cells_set:

                perimeter += 1

    return perimeter



def optimize_polyomino(initial_cells, max_moves=100):

    """

    通过局部移动优化 N-omino 的形状，最小化其周长，并检查尺寸约束。

    """

    current_cells = initial_cells.copy()

    # 初始周长可能较大，不需要担心最小化目标

    current_perimeter = calculate_perimeter_for_set(current_cells) 

    

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] 

    

    for _ in range(max_moves):

        best_perimeter_reduction = 0

        best_move = None 

        

        removable_cells = list(current_cells)

        random.shuffle(removable_cells)

        

        for r_remove, c_remove in removable_cells:

            

            # 确保移除后形状保持连通性 (省略了连通性检查以简化，但连通性通常是必需的)

            # 在这种局部优化中，移动到邻居通常不会破坏大型连通组件，所以我们暂时忽略此检查。

            

            for dr, dc in directions:

                r_add, c_add = r_remove + dr, c_remove + dc

                

                if (0 <= r_add < GRID_SIZE and 0 <= c_add < GRID_SIZE and 

                    (r_add, c_add) not in current_cells):



                    new_cells = current_cells.copy()

                    new_cells.remove((r_remove, c_remove))

                    new_cells.add((r_add, c_add))

                    

                    # 关键检查 1: 确保新形状满足尺寸限制

                    if not check_dims_constraint(new_cells):

                        continue

                        

                    # 优化检查：新周长是否更好

                    new_perimeter = calculate_perimeter_for_set(new_cells)

                    reduction = current_perimeter - new_perimeter

                    

                    if reduction > best_perimeter_reduction:

                        best_perimeter_reduction = reduction

                        best_move = ((r_remove, c_remove), (r_add, c_add))



        if best_move and best_perimeter_reduction > 0:

            (r_remove, c_remove), (r_add, c_add) = best_move

            current_cells.remove((r_remove, c_remove))

            current_cells.add((r_add, c_add))

            current_perimeter -= best_perimeter_reduction

        else:

            break

            

    return current_cells



def generate_and_optimize_polyomino(N, max_optimization_moves=100, max_init_attempts=50):

    """

    生成一个随机的连通形状，然后通过周长优化使其紧凑。

    """

    initial_cells = None

    

    # 周长优化不用于长条/紧凑模式的切换，它只是最小化周长。

    # 我们仍然使用随机生成 + 尺寸限制来确保形状是可用的。

    

    for attempt in range(max_init_attempts):

        temp_cells = set()

        # 在大网格的中心区域随机选择起点

        start_r = random.randint(GRID_SIZE // 2 - 2, GRID_SIZE // 2 + 1) 

        start_c = random.randint(GRID_SIZE // 2 - 2, GRID_SIZE // 2 + 1)

        

        temp_cells.add((start_r, start_c))

        

        boundary_candidates = set()

        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] 

        

        # 初始化边界

        for dr, dc in directions:

            nr, nc = start_r + dr, start_c + dc

            if 0 <= nr < GRID_SIZE and 0 <= nc < GRID_SIZE:

                 boundary_candidates.add((nr, nc))



        count = 1

        

        # 随机连通生长 (随机 BFS)

        while count < N and boundary_candidates:

            next_cell = random.choice(list(boundary_candidates))

            nr, nc = next_cell

            

            temp_cells.add((nr, nc))

            count += 1

            

            boundary_candidates.remove(next_cell)

            

            # 更新边界

            for dr, dc in directions:

                nnr, nnc = nr + dr, nc + dc

                if 0 <= nnr < GRID_SIZE and 0 <= nnc < GRID_SIZE and (nnr, nnc) not in temp_cells:

                    boundary_candidates.add((nnr, nnc))

        

        if count == N and check_dims_constraint(temp_cells):

            initial_cells = temp_cells

            break



    if initial_cells is None:

        return set()



    optimized_cells = optimize_polyomino(initial_cells, max_optimization_moves)

    

    return optimized_cells





class ModItem:

    """代表一个枪械强化模组"""

    def __init__(self, quality, monster_level, bias_type="游荡者"):

        self.quality = quality

        self.monster_level = monster_level

        self.bias_type = bias_type

        self.bias_display_name = cfg.BIAS_DISPLAY_NAMES.get(bias_type, "未知")



        settings = cfg.QUALITY_SETTINGS[self.quality]

        self.n = random.randint(*settings["n_range"]) # 词条数量

        self.c = random.randint(*settings["c_range"]) # 方格大小 (N)

        self.b = settings["b"] # 品质系数

        self.color = cfg.QUALITY_COLORS[self.quality]

        

        # 形状生成模式不再需要，因为优化器本身倾向于紧凑/长条

        self.shape_mode = "Optimized" 



        # 使用新的优化算法生成形状

        self.shape = self._generate_shape() 

        self.affixes = self._generate_affixes() # 词缀列表



    def _generate_shape(self):

        """

        [重构] 使用周长优化算法生成形状。

        """

        # 尝试生成和优化形状，c 即为 N (单元格数量)

        optimized_cells = generate_and_optimize_polyomino(self.c)

        

        if not optimized_cells:

            # 如果生成失败，回退到单个方块

            return self._normalize_shape({(0, 0)}) 



        # 归一化形状，将其左上角移动到 (0, 0)

        return self._normalize_shape(optimized_cells)



    def _get_neighbors(self, cell, existing_cells, is_frontier=False):

        """获取一个单元格的相邻（非对角线）单元格 (原辅助函数，但功能现在主要在外部实现)"""

        r, c = cell

        neighbors = set()

        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:

            nr, nc = r + dr, c + dc

            if is_frontier:

                if (nr, nc) not in existing_cells:

                    neighbors.add((nr, nc))

            else:

                neighbors.add((nr, nc))

        return neighbors



    def _normalize_shape(self, cells):

        """将形状的左上角移动到 (0, 0)"""

        if not cells:

            return set()

        min_r = min(r for r, c in cells)

        min_c = min(c for r, c in cells)

        return set((r - min_r, c - min_c) for r, c in cells)



    def _generate_affixes(self, locked_affixes=None):

        """根据规则生成词缀列表 (保持不变)"""

        if locked_affixes is None:

            locked_affixes = []

            

        affixes = list(locked_affixes) # 包含锁定的词条

        num_to_generate = self.n - len(locked_affixes)

        

        # 1. 构建加权词缀池

        weighted_pool = {}

        bias = cfg.MONSTER_DROP_BIAS.get(self.bias_type, {})



        for pool_name, pool_affixes in cfg.AFFIX_POOLS.items():

            pool_weight_bonus = bias.get(pool_name, 0)

            for affix_name, base_weight in pool_affixes.items():

                specific_bonus = bias.get(affix_name, 0)

                total_weight = base_weight + pool_weight_bonus + specific_bonus

                if total_weight > 0:

                    weighted_pool[affix_name] = total_weight

        

        pool_keys = list(weighted_pool.keys())

        pool_weights = list(weighted_pool.values())



        # 2. 随机选择词缀

        if not pool_keys: 

            print(f"警告: {self.bias_type} 的词缀池为空。")

            return affixes



        chosen_names = random.choices(pool_keys, weights=pool_weights, k=num_to_generate)

        

        # 3. 计算词缀数值

        for name in chosen_names:

            base_val = cfg.BASE_STAT_VALUES.get(name, 0)

            

            # 数值计算公式 (基于品质系数 b, 空间大小 c, 和怪物等级)

            value = (base_val * self.b) * \

                    (1 + self.c * cfg.SPACE_GROWTH_FACTOR) * \

                    (1 + self.monster_level * cfg.LEVEL_GROWTH_FACTOR)

            

            # 随机浮动和取整

            if base_val < 1.0:

                value *= random.uniform(0.9, 1.1)

            else:

                value = int(value * random.uniform(0.9, 1.1))



            affixes.append({"name": name, "value": value, "is_main": False})

        

        # 标记第一个为主属性

        if affixes:

            affixes[0]["is_main"] = True

            

        return affixes



    def reroll_affixes(self, level=1, locked_indices=None):

        """精炼：重新生成词缀 (Lvl 1 或 Lvl 2)"""

        locked_affixes = []

        if level == 2 and locked_indices:

            # 锁定最多前两个词缀

            locked_affixes = [self.affixes[i] for i in locked_indices if i < len(self.affixes)]

            if len(locked_affixes) > 2:

                locked_affixes = locked_affixes[:2]

            

        # 重置主属性标记

        for affix in locked_affixes:

            affix["is_main"] = False



        self.affixes = self._generate_affixes(locked_affixes=locked_affixes)



    def rotate(self):

        """顺时针旋转90度"""

        new_shape = set((c, -r) for r, c in self.shape)

        self.shape = self._normalize_shape(new_shape)



    def get_bounds(self):

        """获取形状的边界 (width, height) in cells"""

        return get_bounding_box_dims(self.shape)



    def draw(self, surface, x, y, cell_size):

        """在指定屏幕坐标(x, y)绘制物品 (修复 1.6.5: 移除内部线条)"""

        # 1. 绘制所有实心方块

        for (r, c) in self.shape:

            cell_rect = pygame.Rect(

                x + c * cell_size,

                y + r * cell_size,

                cell_size,

                cell_size

            )

            pygame.draw.rect(surface, self.color, cell_rect)

            

        # 2. 绘制外边框 (只绘制不与其他方块相邻的边)

        for (r, c) in self.shape:

            cx, cy = x + c * cell_size, y + r * cell_size

            

            # 上边

            if (r-1, c) not in self.shape:

                pygame.draw.line(surface, cfg.COLOR_BACKGROUND, (cx, cy), (cx + cell_size, cy), 1)

            # 下边

            if (r+1, c) not in self.shape:

                pygame.draw.line(surface, cfg.COLOR_BACKGROUND, (cx, cy + cell_size), (cx + cell_size, cy + cell_size), 1)

            # 左边

            if (r, c-1) not in self.shape:

                pygame.draw.line(surface, cfg.COLOR_BACKGROUND, (cx, cy), (cx, cy + cell_size), 1)

            # 右边

            if (r, c+1) not in self.shape:

                pygame.draw.line(surface, cfg.COLOR_BACKGROUND, (cx + cell_size, cy), (cx + cell_size, cy + cell_size), 1)



def create_mod_item(quality, monster_level, bias_type=None):

    """

    创建 ModItem 的工厂函数。

    """

    if bias_type is None:

        # 从配置中获取默认 bias

        bias_type = cfg.QUALITY_SETTINGS[quality]["bias"]

    

    return ModItem(quality, monster_level, bias_type)